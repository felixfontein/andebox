#!/usr/bin/env python

import argparse
import os
import re
import shutil
import subprocess
import sys
import tempfile
import signal
from functools import reduce

import yaml
from distutils.version import LooseVersion


PLUGIN_TYPES = ('connection', 'lookup', 'modules', 'doc_fragments', 'module_utils', 'callback', 'inventory')


class AnsibleTestError(Exception):
    pass


class IgnoreFileEntry(object):
    pattern = re.compile(r'^(?P<filename>\S+)\s(?P<ignore>\S+)(?:\s+#\s*(?P<comment>)\S.*\S)?\s*$')
    file_filter = None
    check_filter = None
    file_parts_depth = None

    def __init__(self, filename, ignore, comment):
        self.filename = filename
        self._file_parts = self.filename.split("/")

        if ':' in ignore:
            self.ignore, self.error_code = ignore.split(":")
        else:
            self.ignore, self.error_code = ignore, None
        self.comment = comment

    @property
    def ignore_check(self):
        return "{0}:{1}".format(self.ignore, self.error_code) if self.error_code else self.ignore

    @property
    def rebuilt_comment(self):
        return " # {0}".format(self.comment) if self.comment else ""

    @property
    def file_parts(self):
        if self.file_parts_depth is None:
            return os.path.join(*self._file_parts)

        return os.path.join(*self._file_parts[:self.file_parts_depth])

    def __str__(self):
        return "<IgnoreFileEntry: {0} {1}{2}>".format(self.filename, self.ignore_check, self.rebuilt_comment)

    def __repr__(self):
        return str(self)

    @staticmethod
    def parse(line):
        match = IgnoreFileEntry.pattern.match(line)
        if not match:
            raise ValueError("Line cannot be parsed as an ignore-file entry: {0}".format(line))

        ffilter = IgnoreFileEntry.file_filter
        if ffilter is not None:
            ffilter = ffilter if isinstance(ffilter, re.Pattern) else re.compile(ffilter)
            if not ffilter.search(match.group("filename")):
                return

        ifilter = IgnoreFileEntry.check_filter
        if ifilter is not None:
            ifilter = ifilter if isinstance(ifilter, re.Pattern) else re.compile(ifilter)
            if not ifilter.search(match.group("ignore")):
                return

        return IgnoreFileEntry(match.group("filename"), match.group("ignore"), match.group("comment"))


class ResultLine(object):
    def __init__(self, file_part, ignore_check, count=1):
        self.file_part = file_part
        self.ignore_check = ignore_check
        self.count = count

    def increase(self):
        self.count = self.count + 1
        return self

    def __lt__(self, other):
        return self.count < other.count

    def __le__(self, other):
        return self.count <= other.count

    def __gt__(self, other):
        return self.count > other.count

    def __ge__(self, other):
        return self.count >= other.count

    def __eq__(self, other):
        return self.count == other.count

    def __ne__(self, other):
        return self.count != other.count

    def __str__(self):
        r = ["{0:6} ".format(self.count)]
        if self.file_part:
            r.append(" ")
            r.append(self.file_part)
        if self.ignore_check:
            r.append(" ")
            r.append(self.ignore_check)
        return "".join(r)

    def __repr__(self):
        r = ["<ResultLine: ", str(self.count), ","]
        if self.file_part:
            r.append(" ")
            r.append(self.file_part)
        if self.ignore_check:
            r.append(" ")
            r.append(self.ignore_check)
        r.append(">")
        return "".join(r)


def build_argparser():
    parser = argparse.ArgumentParser(description="Ansible Collection Developer's Box")
    parser.add_argument("--collection", "-c", help="Ansible name for the collection, in the form namespace.name")
    subparser = parser.add_subparsers(dest="action", required=True)

    # test - run ansible-test
    parser_test = subparser.add_parser("test", help="Runs ansible-test in a temporary environment")
    parser_test.add_argument("--keep", "-k", action="store_true", help="Keep temporary directory after execution")
    parser_test.add_argument("ansible_test_params", nargs='+')
    parser_test.epilog = "Notice the use of '--' to delimit andebox's options from ansible-test's"
    parser_test.usage = "%(prog)s usage: andebox test [-h] [--keep] -- [ansible_test_params ...]"

    # ignores - manage ignore files
    parser_ignores = subparser.add_parser("ignores", help="Gathers stats on ignore*.txt file(s)")
    parser_ignores.add_argument(
        "--ignore-file-spec", "-ifs", choices=["2.9", "2.10", "2.11", "-"],
        help="Use the ignore file matching this Ansible version. The special value '-' may be specified to read "
             "from stdin instead. If not specified, will use all available files"
    )
    parser_ignores.add_argument("--depth", "-d", type=int, help="Path depth for grouping files")
    parser_ignores.add_argument("--file-filter", "-pf", type=re.compile,
                                help="Regexp matching file names to be included")
    parser_ignores.add_argument("--check-filter", "-cf", type=re.compile,
                                help="Regexp matching checks in ignore files to be included")
    parser_ignores.add_argument("--supress-files", "-sf", action="store_true",
                                help="Supress file names from the output, consolidating the results")
    parser_ignores.add_argument("--supress-checks", "-sc", action="store_true",
                                help="Supress the checks from the output, consolidating the results")
    parser_ignores.add_argument("--head", "-H", type=int, default=10,
                                help="Number of lines to display in the output: leading lines if positive,"
                                     " trailing lines if negative, all lines if zero.")

    # depre - check for plugin deprecations
    parser_depre = subparser.add_parser("depre", help="Returns deprecation information for plugin")
    parser_depre.add_argument("--plugin-type", "-pt", choices=PLUGIN_TYPES,
                              help="Keep temporary directory after execution")
    parser_depre.add_argument("--regex", "--regexp", "-r", action="store_true",
                              help="Treat plugin names as regular expressions")
    parser_depre.add_argument("plugin_names", nargs='+')

    return parser


def read_coll_meta():
    with open("galaxy.yml") as galaxy_meta:
        meta = yaml.load(galaxy_meta, Loader=yaml.BaseLoader)
    return meta['namespace'], meta['name'], meta['version']


def determine_collection(coll_arg):
    if coll_arg:
        coll_split = coll_arg.split('.')
        return '.'.join(coll_split[:-1]), coll_split[-1]
    return read_coll_meta()[:2]


def run_ansible_test(args):
    coll_vars = {}

    coll_vars['namespace'], coll_vars['collection'] = determine_collection(args.collection)

    coll_vars['top_dir'] = tempfile.mkdtemp(prefix="andebox.")
    coll_vars['coll_dir'] = os.path.join(
        coll_vars['top_dir'], "ansible_collections", coll_vars['namespace'], coll_vars['collection']
    )
    os.makedirs(coll_vars['coll_dir'])
    for v in ('namespace', 'collection', 'top_dir', 'coll_dir'):
        print("{0:10} = {1}".format(v, coll_vars[v]), file=sys.stderr)
    print(file=sys.stderr)

    try:
        # copy files to tmp ansible coll dir
        with os.scandir() as it:
            for entry in it:
                if entry.name.startswith('.'):
                    continue
                if entry.is_dir():
                    shutil.copytree(entry.name, os.path.join(coll_vars['coll_dir'], entry.name))
                else:
                    shutil.copy(entry.name, os.path.join(coll_vars['coll_dir'], entry.name))

        os.putenv('COLLECTIONS_PATH', ':'.join([coll_vars['coll_dir']] + os.environ.get('COLLECTIONS_PATH', '').split(':')))
        rc = subprocess.call(["ansible-test"] + args.ansible_test_params, cwd=coll_vars['coll_dir'])

        if rc != 0:
            raise AnsibleTestError("Error running ansible-test (rc={0})".format(rc))

    finally:
        if not args.keep:
            shutil.rmtree(coll_vars['top_dir'])
        else:
            print('Keeping temporary directory: {0}'.format(coll_vars['coll_dir']))


def make_fh_list_for_version(version):
    ignore_path = os.path.join('.', 'tests', 'sanity')
    if version == "-":
        return [sys.stdin]
    if version:
        return [open(os.path.join(ignore_path, 'ignore-{0}.txt'.format(version)))]
    else:
        with os.scandir(os.path.join(ignore_path)) as it:
            return [open(os.path.join(ignore_path, entry.name))
                    for entry in it
                    if entry.name.startswith("ignore-") and entry.name.endswith(".txt")]


def read_ignore_file(fh):
    result = []
    with fh:
        for line in fh.readlines():
            entry = IgnoreFileEntry.parse(line)
            if entry:
                result.append(entry)
    return result


def retrieve_ignore_entries(version):
    return reduce(lambda a, b: a+b,
                  [read_ignore_file(fh) for fh in make_fh_list_for_version(version)])


def filter_lines(lines, num):
    if num == 0:
        return lines
    return lines[num:] if num < 0 else lines[:num]


def manages_ignores(args):
    if args.file_filter:
        IgnoreFileEntry.file_filter = args.file_filter
    if args.check_filter:
        IgnoreFileEntry.check_filter = args.check_filter
    if args.depth:
        IgnoreFileEntry.file_parts_depth = args.depth

    try:
        ignore_entries = retrieve_ignore_entries(args.ignore_file_spec)
    except Exception as e:
        print("Error reading ignore file: {0}".format(args.ignore_file_spec), file=sys.stderr)
        raise e

    count_map = {}
    for entry in ignore_entries:
        fp = entry.file_parts if not args.supress_files else ""
        ic = entry.ignore_check if not args.supress_checks else ""
        key = fp + "|" + ic
        count_map[key] = count_map.get(key, ResultLine(fp, ic, 0)).increase()

    lines = [str(s) for s in sorted(count_map.values(), reverse=True)]
    print("\n".join(filter_lines(lines, args.head)))


def print_depre(name, node, curr_version):
    redir, tomb, depre = [node.get(x) for x in ('redirect', 'tombstone', 'deprecation')]
    if redir:
        print('R {0}: redirected to {1}'.format(name, redir))
        return
    if tomb:
        print('T {0}: dead in {1}: {2}'.format(name, tomb['removal_version'], tomb['warning_text']))
        return
    if depre:
        print('D {0}: deprecation in {1} (current={2}): {3}'.format(
            name, depre['removal_version'], curr_version, depre['warning_text']))
        return


def depre_process_plugin(regex, name_param, runtime, plugin_types, curr_version):
    for plugin_type in plugin_types:
        if regex:
            pattern = re.compile(name_param)
            matches = [n
                       for n in runtime[plugin_type]
                       if pattern.search(n)]
            for name in matches:
                print_depre('.'.join(plugin_type, name), runtime[plugin_type][name], curr_version)
        else:
            if name_param.endswith('.py'):
                name = name_param.split('/')[-1]
                name = name.split('.')[0]
            else:
                name = name_param
            if name in runtime[plugin_type]:
                print_depre('.'.join(plugin_type, name), runtime[plugin_type][name], curr_version)


def deprecated(args):
    with open(os.path.join("meta", "runtime.yml")) as runtime_yml:
        runtime = yaml.load(runtime_yml, Loader=yaml.BaseLoader)

    plugin_types = [args.plugin_type] if args.plugin_type else PLUGIN_TYPES
    _, _, curr_version = read_coll_meta()

    for name in args.plugin_names:
        depre_process_plugin(args.regex, name, runtime, plugin_types, curr_version)


def main():
    actions = dict(
        test=run_ansible_test,
        ignores=manages_ignores,
        depre=deprecated,
    )

    parser = build_argparser()
    args = parser.parse_args()
    action = actions[args.action]
    action(args)


if __name__ == '__main__':
    try:
        signal.signal(signal.SIGPIPE, signal.SIG_DFL)
        main()
    except KeyboardInterrupt:
        exit(2)
    except (BrokenPipeError, IOError):
        pass
    except AnsibleTestError as e:
        print(str(e), file=sys.stderr)
        exit(1)
